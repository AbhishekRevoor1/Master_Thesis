\chapter{Toolchain Implementation}
\label{ch:toolchain}

\section{Overview}
This chapter describes the implementation of the complete RWU-RV64I toolchain used to compile, link, and execute bare-metal C programs on the custom RISC-V processor.  
The toolchain was designed around the open-source GNU RISC-V environment and adapted to meet the specific constraints of the RWU-RV64I hardware.  
Its purpose is to convert C source programs into loadable ELF and Verilog memory images that are compatible with the FPGA-based Harvard architecture.  

The implementation includes:
\begin{itemize}
    \item Installation and configuration of the GNU RISC-V toolchain.
    \item A custom \texttt{linker.ld} defining instruction and data memory regions.
    \item A minimal \texttt{crt0.s} startup file responsible for runtime initialization.
    \item A C header (\texttt{rwu-rv64i.h}) providing memory definitions and helper routines.
\end{itemize}

\section{Installing the GNU RISC-V Toolchain on Linux}
The GNU RISC-V toolchain can be installed on most Linux distributions using either the pre-built packages or by compiling from source.  
For this project, the toolchain was installed on Ubuntu 24.04 LTS using the official RISC-V GNU Toolchain repository maintained by the RISC-V International community.

\subsection{System Requirements}
Before installation, the following development utilities must be present:
\begin{verbatim}
sudo apt update
sudo apt install autoconf automake autotools-dev curl \
    python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential \
    bison flex texinfo gperf libtool patchutils bc zlib1g-dev git
\end{verbatim}

These packages provide all dependencies required for building GCC, binutils, and newlib.

\subsection{Toolchain Source Installation}
To build the complete bare-metal toolchain:

\begin{enumerate}
\item Clone the official repository:
\begin{verbatim}
git clone https://github.com/riscv-collab/riscv-gnu-toolchain.git
cd riscv-gnu-toolchain
\end{verbatim}

\item Configure the build for a bare-metal (ELF) target:
\begin{verbatim}
./configure --prefix=/opt/riscv --with-arch=rv64i --with-abi=lp64
\end{verbatim}

\item Build and install:
\begin{verbatim}
make -j$(nproc)
sudo make install
\end{verbatim}

\item Add the toolchain to the system path:
\begin{verbatim}
export PATH=/opt/riscv/bin:$PATH
\end{verbatim}
\end{enumerate}

After installation, the following commands should report valid toolchain versions:
\begin{verbatim}
riscv64-unknown-elf-gcc --version
riscv64-unknown-elf-ld --version
riscv64-unknown-elf-objcopy --version
\end{verbatim}

This toolchain provides all the necessary utilities to compile and link bare-metal applications without operating-system dependencies.

\section{Toolchain Configuration}
The GNU RISC-V cross-compilation toolchain (\texttt{riscv64-unknown-elf}) was configured to target the \texttt{RV64I} base instruction set architecture with control and status register (CSR) support.  
The compiler was invoked using the following configuration options:

\begin{verbatim}
riscv64-unknown-elf-gcc -march=rv64i -mabi=lp64 -ffreestanding -nostdlib\
-O2 -g -msmall-data-limit=0 -Iinclude -c program.c -o program.o
\end{verbatim}

\begin{itemize}
  \item \texttt{-march=rv64i}: Specifies the target architecture as the 64-bit RISC-V integer base ISA.  
  \item \texttt{-mabi=lp64}: Selects the LP64 application binary interface, where long and pointer types are 64 bits.  
  \item \texttt{-ffreestanding}: Indicates that the program is built for a freestanding environment without standard libraries or operating system dependencies.  
  \item \texttt{-nostdlib}: Prevents the linker from automatically including standard startup files or linking against system libraries.  
  \item \texttt{-O2}: Enables compiler optimizations for improved performance while maintaining reasonable compilation time.  
  \item \texttt{-g}: Includes debugging information for use with simulators or debuggers.  
  \item \texttt{-msmall-data-limit=0}: Disables the use of the small data area, ensuring all objects are accessed via full 64-bit addressing.  
\end{itemize}

This configuration ensures that the generated binaries are fully compatible with the custom RWU-RV64I hardware implementation and operate independently of any operating system or runtime environment.


The resulting object files are linked with a custom \texttt{linker.ld} and a minimal \texttt{crt0.s} to form an executable ELF binary.  
Finally, \texttt{objcopy} converts the ELF into a Verilog memory file used by the simulator.

\section{Hardware Context and Memory Architecture}
The RWU-RV64I processor implements a strict Harvard architecture with physically separate instruction (IMEM) and data (DMEM) memories synthesized inside the FPGA.  
For simulation simplicity, both share the same logical base address \texttt{0x0000\_0000} in the linker configuration, although they exist as distinct memory blocks.

\begin{table}[h]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Region} & \textbf{Origin} & \textbf{Size} & \textbf{Attributes} & \textbf{Purpose}\\
\midrule
IMEM & 0x0000\_0000 & 32 KB & Read/Execute & Instruction storage\\
DMEM & 0x0000\_0000 & 8 KB  & Read/Write   & Data memory and stack\\
GPIO & 0x0001\_0000 & 48 B & Memory-mapped I/O & Peripheral output\\
\bottomrule
\end{tabular}
\caption{RWU-RV64I memory configuration used in the toolchain.}
\end{table}

The instruction fetch and data access operate in parallel since IMEM and DMEM are physically isolated.  
This organization imposes important restrictions on the software toolchain, primarily the inability to access instruction memory as data.

% ============================================================
\section{Linker Script Development}
\label{sec:linker_script}

The linker script defines the memory layout and placement of program sections within the RWU-RV64I processor architecture.  
It plays a critical role in mapping the compiled code and data to the physical memory addresses of the system.  
Since RWU-RV64I employs a Harvard architecture, the linker separates code and data into two distinct regions: Instruction Memory (IMEM) and Data Memory (DMEM). The complete linker script used in this work is provided in Appendix~\ref{app:linker_script} for reference.

\subsection*{Memory organization}

The processor uses two independent address spaces:
\begin{itemize}
  \item \textbf{IMEM:} Stores program instructions and constant data (\texttt{.text} and \texttt{.rodata} sections).
  \item \textbf{DMEM:} Stores runtime data such as global variables, the stack, and uninitialized memory (\texttt{.bss} section).
\end{itemize}

\subsection*{Key roles of the linker script}

The linker script performs the following essential tasks:
\begin{enumerate}
  \item Defines the origin and size of both IMEM and DMEM regions.
  \item Places each program section into the correct memory region based on its access type.
  \item Generates special symbols (labels) that are later used by the startup and runtime code for memory initialization.
\end{enumerate}

\subsection*{Important linker-defined symbols}

\begin{itemize}
  \item \texttt{\_\_bss\_start} and \texttt{\_\_bss\_end}: Define the boundaries of the \texttt{.bss} section.  
        These are used by the startup file to clear uninitialized memory.
  \item \texttt{\_\_stack\_top}: Marks the initial location of the stack pointer.  
        The stack grows downward from this address during program execution.
  \item \texttt{\_user\_dmem\_start}: Indicates the start of user data storage in DMEM, after the \texttt{.bss} section.
\end{itemize}

\subsection*{Section allocation overview}

The general allocation strategy used in the linker script is summarized below:
\begin{itemize}
  \item The \texttt{.text} section is placed at the beginning of IMEM and contains all executable code.
  \item The \texttt{.rodata} section follows immediately, storing constant values.
  \item The \texttt{.bss} section is mapped into DMEM and occupies all uninitialized writable memory.
  \item The stack pointer is positioned at the upper end of DMEM, and program-generated results are written to DMEM at runtime.
\end{itemize}

\subsection*{Design Rationale}

This separation of code and data ensures that the processor accesses the instruction memory (IMEM) and data memory (DMEM) through independent buses, eliminating resource conflicts and enabling deterministic instruction execution.  
By explicitly defining memory regions, the linker script establishes a consistent reference framework for both the startup code and C programs, ensuring that all sections are placed at predictable addresses during compilation and linking.


% ============================================================
\section{Startup File (crt0.s)}
\label{sec:startup_file}

The startup file is responsible for initializing the system immediately after reset and preparing the runtime environment required by C programs.  
It is written in assembly language and executes before any user-defined functions. The complete assembly listing of the startup file (\texttt{crt0.s}) is provided in the Appendix~\ref{app:startup_file} for detailed reference.


\subsection*{Purpose and responsibilities}

The startup file performs the following actions in a fixed sequence:
\begin{enumerate}
  \item Sets up the stack pointer using the symbol \texttt{\_\_stack\_top} defined by the linker.
  \item Aligns the stack pointer to a 16-byte boundary to maintain ABI compatibility.
  \item Clears the \texttt{.bss} section between \texttt{\_\_bss\_start} and \texttt{\_\_bss\_end}, ensuring all uninitialized global variables start with a zero value.
  \item Calls the \texttt{main()} function to transfer control to the C program.
  \item If \texttt{main()} returns, enters an infinite loop to prevent execution from running into undefined memory.
\end{enumerate}

\subsection*{Memory initialization process}

The \texttt{.bss} clearing loop is implemented using a simple 64-bit store operation sequence.  
It iterates through all addresses in the range between \texttt{\_\_bss\_start} and \texttt{\_\_bss\_end}, setting each to zero.  
This guarantees that all uninitialized global and static variables start in a defined state, as required by the C standard.

\subsection*{Handling of the \texttt{.data} section}

Because RWU-RV64I uses separate instruction and data memories, no automatic copying of initialized variables from IMEM to DMEM occurs at startup.  
As a result, writable variables that require an initial value must be explicitly initialized in the program code itself if needed.  
This approach simplifies the startup process and avoids any dependency between IMEM and DMEM at runtime.

\subsection*{Structure and execution flow}

After completing initialization, the startup code branches to the C entry point \texttt{main()}.  
If execution ever returns from \texttt{main()}, the program loops indefinitely to maintain a stable halted state.  
This behavior ensures predictable operation during simulation or FPGA execution.

A summarized control flow of the startup file is shown below:

\begin{enumerate}
  \item Load \texttt{sp} $\leftarrow$ \texttt{\_\_stack\_top}
  \item Zero memory: from \texttt{\_\_bss\_start} to \texttt{\_\_bss\_end}
  \item Call \texttt{main()}
  \item Loop forever
\end{enumerate}


% ============================================================
\section{Runtime Header File (rwu-rv64i.h)}
\label{sec:runtime_header}

The runtime header defines a minimal set of helper functions and symbolic references that allow C programs to interact with the RWU-RV64I hardware.  
It acts as the interface layer between compiled application code and the memory layout established by the linker and startup files.

\subsection*{Purpose of the runtime header}

The header file provides three key functionalities:
\begin{itemize}
  \item Access to linker-defined symbols such as \path{__bss_start}, \path{__bss_end}, and \path{_user_dmem_start}.
  \item A pointer-based data writer that allows sequential storage of 64-bit values in DMEM.
  \item A GPIO write function that communicates program results to the testbench or hardware outputs.
\end{itemize}


\subsection*{DMEM writer logic}

The header defines a pointer, typically named \texttt{\_\_rwu\_dmem\_next}, which points to the next available address in DMEM for data storage.  
This pointer is initialized by a helper function \texttt{rwu\_dmem\_reset()}, which sets it to \texttt{\_user\_dmem\_start}.  
Each time the program calls \texttt{rwu\_store64()}, the current pointer location is written with a 64-bit value, and then the pointer advances by eight bytes.  

This mechanism allows C programs to store multiple runtime values in a continuous region of DMEM without manually computing memory addresses.  
Such an approach simplifies debugging and makes it easy to observe data changes during simulation.

\subsection*{GPIO interaction}

Another key function, \texttt{rwu\_print()}, performs a direct memory-mapped write to the GPIO output register located at address \texttt{0x00010004}.  
This function is used to send status or result values from the program to the testbench.  
It provides a straightforward way to visualize output without requiring additional hardware interfaces.

\subsection*{Integration with C programs}

The header file is included in all user C applications through the directive:
\begin{verbatim}
#include "rwu-rv64i.h"
\end{verbatim}
By doing so, programs gain access to all runtime definitions and helper functions necessary for DMEM writing and GPIO interaction.

A simplified example of its usage is shown below:

\begin{verbatim}
rwu_dmem_reset();
rwu_store64(result);
rwu_print((uint8_t)result);
\end{verbatim}

The complete header file implementation is available in the Appendix~\ref{app:runtime_header}.

% ============================================================
\section{Summary}
\label{sec:linker_summary}

This part of the toolchain development established the foundational runtime environment for the RWU-RV64I processor.  
The linker script defines how program sections are distributed across IMEM and DMEM;  
the startup file initializes memory and prepares the stack and variables for program execution;  
and the runtime header provides lightweight C functions for data writing and GPIO output.  

Together, these components ensure that C programs compiled for the RWU-RV64I processor execute in a predictable and hardware-consistent manner.  
The structure also provides a clean base for integration within the Eclipse IDE and for later FPGA testing, discussed in the next chapter.
% ============================================================
