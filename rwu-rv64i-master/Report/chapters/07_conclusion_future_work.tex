% ============================================================
\chapter{Conclusion and Future Work}
\label{ch:conclusion}

\section{Conclusion}

This thesis presented the design and implementation of a \textbf{complete software toolchain} for the RWU-RV64I processor, a 64-bit RISC-V–based educational core developed at Hochschule Ravensburg–Weingarten.  
The work successfully bridged the gap between the processor’s hardware implementation and its software programmability, transforming the RWU-RV64I from an assembly-only prototype into a fully functional, C-programmable platform.

The developed toolchain was built around the \textbf{GNU RISC-V compiler suite (GCC and Binutils)} and includes all essential runtime components required for bare-metal program execution:
\begin{itemize}
    \item a custom \texttt{linker.ld} precisely reflecting the processor’s Harvard memory map,
    \item a minimal \texttt{crt0.s} startup file for runtime initialization,
    \item a lightweight runtime header (\texttt{rwu-rv64i.h}) providing DMEM and GPIO interfaces, and
    \item a unified \texttt{Makefile}-based build system automating compilation, linking, image generation, and simulation.
\end{itemize}

The toolchain was fully integrated into the \textbf{Eclipse CDT IDE}, resulting in a reproducible and user-friendly workflow for compiling, simulating, and debugging C programs on the RWU-RV64I.  
Simulation using \textbf{Vivado XSIM} and deployment on the \textbf{Zybo Zynq-7000 FPGA} verified that compiled programs executed correctly, with GPIO and DMEM outputs matching expected results.  
This confirmed correct instruction decoding, memory mapping, and peripheral interfacing across both simulation and hardware domains.

In addition, a detailed analysis of \textbf{compiler optimization behavior} demonstrated that optimization levels significantly affect code size and runtime behavior.  
The experiments revealed that the \texttt{-O2} and \texttt{-Os} levels produced compact, reliable binaries, whereas unoptimized (\texttt{-O0}) builds often failed due to missing runtime helpers or altered timing observable by the testbench.  
These findings led to stable configuration recommendations for future RWU-RV64I software development.

Overall, this work achieved the following outcomes:
\begin{itemize}
    \item Development of a complete, bare-metal toolchain enabling standard C program execution on RWU-RV64I.
    \item Creation of an automated build and simulation flow validated on both simulation and FPGA hardware.
    \item Integration of the workflow into Eclipse CDT for reproducible, professional-grade development.
    \item Experimental evaluation of compiler optimization levels and establishment of verified defaults.
\end{itemize}

Through these achievements, the RWU-RV64I processor now benefits from a fully operational and extensible development infrastructure that supports academic teaching, research, and future processor extensions.

% ------------------------------------------------------------
\section{Future Work}

Although this thesis established the full foundation for RWU-RV64I software development, several promising directions remain open for future enhancement.

\subsection*{1. Implementation of a Program Loader}
At present, programs are pre-linked and loaded into instruction memory via simulation or FPGA bitstream initialization.  
A logical next step is to design a dedicated \textbf{program loader} capable of transferring compiled binaries into memory at runtime.  
This can be achieved through:
\begin{itemize}
    \item a serial or JTAG-based download interface (e.g., UART or SPI),
    \item an integrated bootloader module in the RWU-RV64I system, and
    \item a lightweight host utility to parse and transmit ELF or raw binary files.
\end{itemize}
Such a loader would remove the need to regenerate FPGA bitstreams for each test and would enable rapid, interactive software deployment.

\subsection*{2. Expansion of Runtime Support and Peripherals}
Future work may extend the runtime system beyond GPIO and DMEM interaction to include:
\begin{itemize}
    \item UART or serial console I/O,
    \item timer peripherals and interrupt handling,
    \item SPI or I\textsuperscript{2}C communication interfaces, and
    \item a minimal C runtime library (subset of \texttt{libc}) for higher-level applications.
\end{itemize}
These extensions would move the RWU-RV64I platform closer to real-world embedded-system capabilities while maintaining its educational simplicity.

\subsection*{3. Debugging and Profiling Infrastructure}
Adding \textbf{GDB remote debugging} support through JTAG or UART would enable step-wise execution and register inspection from Eclipse or command-line tools.  
Incorporating \textbf{cycle-accurate performance counters} in hardware would further allow profiling and timing analysis, strengthening the platform’s use for teaching compiler and architecture co-design.


\subsection*{4. Educational and Research Extensions}
The modular toolchain developed in this work can serve as the foundation for advanced projects such as:
\begin{itemize}
    \item porting a minimal RTOS or cooperative scheduler,
    \item adding compiler backend modifications for experimental instruction-set extensions, and
    \item integrating formal verification frameworks to link software semantics with hardware execution traces.
\end{itemize}

% ------------------------------------------------------------
\section{Summary}

In summary, this thesis delivered a complete and extensible software toolchain for the RWU-RV64I processor, converting it into a fully usable research and teaching platform.  
The developed environment enables reproducible compilation, linking, and hardware execution of standard C programs on a custom 64-bit RISC-V core.  
Future developments such as dynamic program loading, peripheral expansion, and advanced debugging support will further enhance the platform’s capabilities and ensure its continued relevance in RISC-V–based embedded system education at Hochschule Ravensburg–Weingarten.

% ============================================================
