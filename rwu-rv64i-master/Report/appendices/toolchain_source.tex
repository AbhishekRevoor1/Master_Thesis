% ============================================================
\appendix
\chapter{Toolchain Source Listings}
\label{app:toolchain_appendix}

This appendix contains the complete source listings of the toolchain components developed for the RWU-RV64I processor.  
These files correspond to the implementations discussed in Chapter~\ref{ch:toolchain}.  
Each listing is presented in its verified form, which was used during simulation and FPGA testing.

% ------------------------------------------------------------
\section{Linker Script (\texttt{linker.ld})}
\label{app:linker_script}

The linker script defines the memory organization of the RWU-RV64I system, allocating each program section to either instruction or data memory according to access type.  
It also declares key symbols that are referenced in the startup and runtime header files.

\begin{lstlisting}[language=C,caption={RWU-RV64I Linker Script},label={lst:linker_script}]
OUTPUT_ARCH(riscv)
ENTRY(_start)

IMEM_ORIGIN = 0x00000000;
IMEM_SIZE   = 32K;

DMEM_ORIGIN = 0x00000000;
DMEM_SIZE   = 8K;

/* Memory regions */
MEMORY
{
  IMEM (rx) : ORIGIN = IMEM_ORIGIN, LENGTH = IMEM_SIZE
  DMEM (rw) : ORIGIN = DMEM_ORIGIN, LENGTH = DMEM_SIZE
}

/* Convenience symbols */
PROVIDE(_dmem_origin = ORIGIN(DMEM));
PROVIDE(_dmem_size   = LENGTH(DMEM));

SECTIONS
{
    /* Put text/rodata in IMEM (LMA=VMA=IMEM) */
    . = ORIGIN(IMEM);
    .text : {
        PROVIDE(_text_start = .);
        *(.text*)
        *(.rodata*)
        *(.srodata*)
        PROVIDE(_text_end = .);
    } > IMEM

    /* Put bss at start of DMEM (NOLOAD) */
    . = ORIGIN(DMEM);
    .bss (NOLOAD) : {
        PROVIDE(__bss_start = .);
        *(.sbss*)
        *(.bss*)
        *(COMMON)
        PROVIDE(__bss_end = .);
    } > DMEM

    /* Stack top at end of DMEM */
    PROVIDE(__stack_top = ORIGIN(DMEM) + LENGTH(DMEM));

    /* User DMEM start is immediately after .bss (no reserved gap) */
    PROVIDE(_user_dmem_start = __bss_end);

    /* Discard sections not needed */
    /DISCARD/ : { *(.eh_frame) *(.comment) }
}
\end{lstlisting}

% ------------------------------------------------------------
\section{Startup Assembly File (\texttt{crt0.s})}
\label{app:startup_file}

The startup file initializes the processor state and memory immediately after reset.  
It sets the stack pointer, clears the \texttt{.bss} section, and transfers control to the \texttt{main()} function.

\begin{lstlisting}[language={[x86masm]Assembler},caption={RWU-RV64I Startup File},label={lst:startup_file}]
/* crt0.s -- minimal RISC-V startup
 *
 * Behavior:
 *  - Set sp = __stack_top (from linker)
 *  - Zero .bss region [__bss_start, __bss_end)
 *  - Jump to main()
 *
 * NOTE: This startup intentionally does NOT copy .data from IMEM to DMEM.
 */

    .section .init
    .option norvc
    .global _start
    .type   _start,@function

_start:
    /* Load stack pointer from linker symbol __stack_top */
    la      sp, __stack_top
    /* Align stack to 16 bytes just in case */
    andi    sp, sp, -16

    /* Zero .bss from __bss_start to __bss_end, 8-bytes at a time */
    la      t0, __bss_start  /* t0 -> start */
    la      t1, __bss_end    /* t1 -> end */
1:
    beq     t0, t1, 2f
    sd      x0, 0(t0)
    addi    t0, t0, 8
    blt     t0, t1, 1b
2:

    /* Call main() */
    call    main

halt:
    /* If main returns, hang here forever */
    j       halt

    .size _start, .-_start
\end{lstlisting}

% ------------------------------------------------------------
\section{Runtime Header File (\texttt{rwu-rv64i.h})}
\label{app:runtime_header}

The runtime header defines the essential constants, memory references, and helper routines used by the compiled C programs.  
It enables writing results to DMEM and communicating through GPIO.

\begin{lstlisting}[language=C,caption={RWU-RV64I Runtime Header File},label={lst:runtime_header}]
#ifndef RWU_RV64I_H
#define RWU_RV64I_H

#include <stdint.h>
#include <stddef.h>

/* ----------------- Memory Map ---------------- */
#define IMEM_BASE       0x00000000UL
#define IMEM_SIZE       (32 * 1024UL)

#define DMEM_BASE       0x00000000UL
#define DMEM_SIZE       (8 * 1024UL)

/* ----------------- GPIO Mapping ---------------- */
#define GPIO_BASE       0x00010000UL   /* Must match RTL */
#define GPIO_OUT_OFFSET 4

#define GPIO_REG_OUT (*(volatile uint8_t *)(GPIO_BASE + GPIO_OUT_OFFSET))

/* ----------------- Linker Symbols ---------------- */
extern char __bss_start[];
extern char __bss_end[];
extern char __stack_top[];
extern uint64_t _user_dmem_start[];

/* ----------------- GPIO Writer ---------------- */
static inline void rwu_print(uint8_t value)
{
	GPIO_REG_OUT = value;
}

/* ----------------- DMEM Writer ---------------- */
static volatile uint64_t *__rwu_dmem_next;

static inline void rwu_dmem_reset(void)
{
	__rwu_dmem_next = _user_dmem_start;
}

/* Store 64-bit value and advance pointer */
static inline void rwu_store64(uint64_t v)
{
    *__rwu_dmem_next++ = v;
}

#endif /* RWU_RV64I_H */
\end{lstlisting}




% ------------------------------------------------------------
\section{Build Makefile (embedded)}
\label{app:makefile_embedded}

The Makefile below drives firmware compilation and the conversion into Verilog memory files used for simulation.  
\textbf{Recommendation:} upload the real \texttt{Makefile} to the project root (as shown in the Overleaf tree) and include it directly so the PDF preserves literal tabs.

\bigskip

\IfFileExists{Makefile}{%
  \begin{center}
  \lstinputlisting[
    language=MakefileCustom,
    caption={RWU-RV64I combined firmware + simulation Makefile (embedded) — \path{Makefile}},
    label={lst:makefile_embedded},
    columns=fullflexible,
    keepspaces=true
  ]{Makefile}
  \end{center}
}{%
  \noindent\textbf{Makefile not found.} Please ensure the file \texttt{Makefile} is uploaded to the project root.\par
}

\clearpage
\chapter{Optimization Test Programs}
\label{app:optimization-programs}

This appendix lists the three C programs used in the optimization experiments.  
Each program was compiled with the freestanding RWU-RV64I toolchain using identical compiler options except for the optimization level (\texttt{-O0} - \texttt{-Ofast}).  
Including the source files directly ensures reproducibility and transparency of all tests.

% ------------------------------------------------------------
\subsection*{Program 1 – opt\_workload.c}
\lstinputlisting[
  language=C,
  caption={opt\_workload.c — multi-part workload exercising arithmetic, switch, and memory routines},
  label={lst:opt_workload},
  breaklines=true,
  columns=fullflexible
]{opt_workload.c}

% ------------------------------------------------------------
\subsection*{Program 2 – test.c (Square Test)}
\lstinputlisting[
  language=C,
  caption={test.c — square computation and conditional marker output},
  label={lst:test_square},
  breaklines=true,
  columns=fullflexible
]{test.c}

% ------------------------------------------------------------
\subsection*{Program 3 – test\_simple\_gpio.c}
\lstinputlisting[
  language=C,
  caption={test\_simple\_gpio.c — simple arithmetic and predictable GPIO pattern},
  label={lst:test_simple_gpio},
  breaklines=true,
  columns=fullflexible
]{test_simple_gpio.c}

\bigskip
\noindent
Each listing shows the exact C source as compiled during the optimization experiments (see Chapter~\ref{ch:optimizations}).
