The following list (Table) shows the internal signals of the ALU. The table shows the signal name, the width, the driver, the target and a short explanation.
\begin{itemize}
  \item Signal: aluSel\_i[0]
  \begin{itemize}
    \item Width: 1\,bit
    \item Source: aluSel\_i
    \item Destination: aluResult\_o, overf\_s
    \item Explanation (special signal): 
    \begin{itemize}
      \item if aluSel\_i[0] = 0, it is an ADD instruction
      \item ... the second operand must be taken as it is
      \item ... the carry-in of the addition is 0 (aluSel\_i[0])
      \item if aluSel\_i[0] = 1, it is a SUB instruction
      \item ... the second operand must be the 2-complement
      \item ... the carry-in of the addition is 1 which acts as the +1 (aluSel\_i[0])
    \end{itemize}
  \end{itemize}
  \item Signal: data01\_s
  \begin{itemize}
    \item Width: 64\,bit, signed
    \item Source: data01\_i
    \item Destination: aluResult\_o, aluZero\_o
    \item Explanation: It is the signed interpretation of data01\_i. It is needed for some branches (BLT, BGE) and SRA.\[ \mbox{logic signed [reg\_width-1:0] data01\_s;} \]
  \end{itemize}
  \item Signal: data02\_s
  \begin{itemize}
    \item Width: 64\,bit, signed
    \item Source: data02\_i
    \item Destination: aluResult\_o, aluZero\_o
    \item Explanation: It is the signed interpretation of data02\_i. It is needed for some branches  (BLT, BGE) and SRA.\[ \mbox{logic signed [reg\_width-1:0] data02\_s;} \]
  \end{itemize}
  \item Signal: sum\_s
  \begin{itemize}
    \item Width: 64\,bit
    \item Source: data01\_i, cinvb\_s (data02\_i), aluSel\_i[0]
    \item Destination: aluResult\_o
    \item Explanation: It is the sum of the two data inputs data01\_i and data02\_i. The second data input could be negative and so 2-complemented. cinvb\_s is the inversion of data02\_e when $aluSel\_i[0] = 1$, aluSel\_i[0] also acts as the plus 1. \[ \mbox{assign \{carry\_s, sum\_s\}   = data01\_i + cinvb\_s + aluSel\_i[0];} \]
  \end{itemize}
  \item Signal: cinvb\_s
  \begin{itemize}
    \item Width: 64\,bit
    \item Source: data02\_i, aluSel\_i[0]
    \item Destination: sum\_s, carry\_s
    \item Explanation: cinvb\_s is the inversion of data02\_i when $aluSel\_i[0] = 1$. Together with aluSel\_i[0] ($cinvb\_s + aluSel\_i[0]$) it is the 2-complement of data02\_i. \[ \mbox{assign cinvb\_s = aluSel\_i[0] ? ~data02\_i : data02\_i;} \]
  \end{itemize}
  \item Signal: carry\_s
  \begin{itemize}
    \item Width: 1\,bit
    \item Source: data01\_i, cinvb\_s (data02\_i), aluSel\_i[0]
    \item Destination: aluCarr\_o (carry flag)
    \item Explanation: It is the carry of sum\_s. \[ \mbox{assign \{carry\_s, sum\_s\}   = data01\_i + cinvb\_s + aluSel\_i[0];} \]
  \end{itemize}
  \item Signal: sumw\_s
  \begin{itemize}
    \item Width: 32\,bit
    \item Source: data01\_i, cinvb\_s (data02\_i), aluSel\_i[0]
    \item Destination: aluResult\_o
    \item Explanation: For add word, etc. It is the sum of the two data inputs data01\_i(31:0) and data02\_i(31:0. The second data input could be negative and so 2-complemented. cinvbw\_s is the inversion of data02\_e(31:0) when $aluSel\_i[0] = 1$, aluSel\_i[0] also acts as the plus 1. \[ \mbox{assign \{carryw\_s, sumw\_s\}   = data01\_i[31:0] + cinvbw\_s + aluSel\_i[0];} \]
  \end{itemize}
  \item Signal: cinvbw\_s
  \begin{itemize}
    \item Width: 32\,bit
    \item Source: data02\_e, aluSel\_i[0]
    \item Destination: sum\_s, carry\_s
    \item Explanation: For add word, etc. cinvbw\_s is the inversion of data02\_i(31:0) when $aluSel\_i[0] = 1$. Together with aluSel\_i[0] ($cinvbw\_s + aluSel\_i[0]$) it is the 2-complement of data02\_i(31:0). \[ \mbox{assign cinvbw\_s = aluSel\_i[0] ? ~data02\_i[31:0] : data02\_i[31:0];} \]
  \end{itemize}
  \item Signal: carryw\_s
  \begin{itemize}
    \item Width: 1\,bit
    \item Source: data01\_i, cinvb\_s (data02\_i), aluSel\_i[0]
    \item Destination: aluCarr\_o (carry flag)
    \item Explanation: For add word, etc. It is the carry of sumw\_s. \[ \mbox{assign \{carryw\_s, sumw\_s\}   = data01\_i[31:0] + cinvbw\_s + aluSel\_i[0];} \]
  \end{itemize}
  \item Signal: sllw\_s
  \begin{itemize}
    \item Width: 32\,bit
    \item Source: data01\_i, data02\_i
    \item Destination: aluResult\_o
    \item Explanation: SLLW (shift left logical word) \\ 
    Implementation:\\ 
    $sllw\_s = data01\_i(31:0) << data02\_i(4:0)$ \\
    aluResult\_o is sllw\_s, sign extended.
  \end{itemize}
  \item srlw\_s
  \begin{itemize}
    \item Width: 32\,bit
    \item Source: data01\_i, data02\_i
    \item Destination: aluResult\_o
    \item Explanation: SRLW (shift right logical word) \\
    Implementation: \\
    $srlw\_s = data01\_i(31:0) >> data02\_i(4:0)$ \\
    aluResult\_o is srlw\_s, sign extended.
  \end{itemize}
  \item sraw\_s
  \begin{itemize}
    \item Width: 32\,bit, signed
    \item Source: data01\_i, data02\_i
    \item Destination: aluResult\_o
    \item Explanation: SRAW (shift right algorithmic word) \\
    Implementation:\\
    $sraw\_s = data01w\_s >>> data02\_i(4:0)$\\
    aluResult\_o is sraw\_s, sign extended.
  \end{itemize}
  \item data01w\_s
  \begin{itemize}
    \item Width: 32\,bit, signed
    \item Source: data01\_i
    \item Destination: sraw\_s
    \item Explanation: 32 bit signed representation of data01\_i.
  \end{itemize}
  \item sltiu\_s
  \begin{itemize}
    \item Width: 1\,bit
    \item Source: data01\_i, data02\_i
    \item Destination: aluResult\_o
    \item Explanation: SLT, SLTU (set less than; signed, unsigned) \\
    Implementation:  \\
    if(data01\_i < data02\_i)  \\
    sltiu\_s = 1;  \\
    else  \\
    sltiu\_s = 0; \\
    aluResult\_o is sltiu\_s, zero extended.
  \end{itemize}
  \item overf\_s
  \begin{itemize}
    \item Width: 1\,bit
    \item Source: data01\_i, data02\_i, sum\_s, aluSel\_i[0]
    \item Destination: aluOver\_o
    \item Explanation: Overflow occurs when the result-value affects the sign: \\
             - overflow when adding two positives yields a negative \\
             - or, adding two negatives gives a positive \\
             - or, subtract a negative from a positive and get a negative \\
             - or, subtract a positive from a negative and get a positive
  \end{itemize}
  \item aluResult\_o
  \begin{itemize}
    \item Width: 64\,bit
    \item Source: all signals
    \item Destination: output
    \item Explanation: The result of each ALU operation.\\  If aluSel\_i = \\
                                            \begin{tabularx}{0.9\textwidth}{llX}
                                              0 & aluResult\_o = sum\_s; & ADD, ADDI, LB, LH, LW, LBU, LHU, LD, LWU, AUIPC, LUI, SB, SH, SW, SD, JALR, JAL \\
                                              1 & aluResult\_o = sum\_s; & SUB \\
                                              2 & aluResult\_o = data01\_i \& data02\_i; & AND, ANDI \\
                                              3 && \mbox{OR} \\
                                              4 && \mbox{XOR} \\
                                              5 && \mbox{SLT} \\
                                              6 && \mbox{SLTU} \\
                                            \end{tabularx}\\
  \end{itemize}
\end{itemize}
